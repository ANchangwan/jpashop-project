# ✅ 지연 로딩과 성능최적화
1. DTO를 사용해서 데이터를 가져오기
   - 유연성 : 추후 수정 및 필드명 변경할 때 자유롭게 변경 가능하다.
   - 무한 루프가 발생하지 않는다.
   - 보안상 보여주면 안되는 필드를 숨길 수 있다.
   - 배열로 보내지 말고 객체 형태로 보내야 한다.
2. N+1 문제 때문에 페치 조인을 사용하라 -> 성능 최적화
3. 그래도 성능이 최적화가 안되면 DTO 조회를 생각한다.
4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용한다.

# ✅ 컬렉션 조회 최적화

## 1. xxToOne - 패치조인
- 엔티티의 XxxToOne 관계는 모두 패치조인 한다.
- row 수를 증가시키지 않기 때문이다.


## 2. XxxToMany(컬렉션)는 페이징을 하지 않고 조회되는 데이터가 적을 시에는 패치조인을 해도 된다.
- 단, N 쪽에 수 많은 데이터가 있다면 성능 최적화를 고려해야 하기 때문에 페이징 기법을 사용할 수 있으니 패치조인은 사용하지 말자
- 왜냐하면 모든 데이터를 DB에서 읽어오고, Hibernate는 1:N 조인 결과를 모두 메모리에 가져온 다음 1을 기준으로 페이징을 메모리에서 다시 수행해야 한다.
이때, 수백만개의 데이터라면 애플리케이션은 메모리 부족으로 OOM이 발생할 수 있다.

## 3. 컬렉션 조인은 지연로딩 + BatchSize를 정해서 조회하기
- 컬렉션은 지연 로딩으로 조회하는데 성능 최적화를 위해 hibernate.default_batch_fetch_size, @BatchSize를 적용한다.
- IN 쿼리를 통해 한꺼번에 설정한 size 만큼 조회할 수 있다.
- 장점 : row 수가 많아지는 단점을 가진 패치 조인보다 DB 데이터 양이 최적화 된다.

## 주문 조회 V4: JPA에서 DTO 직접 조회
### 1️⃣ “루트 1번, 컬렉션 N번 실행” 이란?

한 번의 쿼리로 주문(Order) 목록(루트 엔티티들) 을 모두 조회하고,

각 주문마다 주문상품(OrderItem) 같은 컬렉션을 따로 N번(주문 개수만큼) 조회하는 방식입니다.

즉:

1개의 쿼리 → 주문들 조회

N개의 쿼리 → 각 주문의 아이템 리스트 조회

➡ 총 1 + N 쿼리 구조

### 2️⃣ 왜 이렇게 나누는가?

ToOne 관계 (@ManyToOne, @OneToOne)

조인해도 데이터 row 수가 늘어나지 않습니다.

예: Order ↔ Member, Order ↔ Delivery

주문 2개면 결과도 row 2개 그대로입니다.

→ 한 번에 join 해서 조회해도 안전하고 효율적이에요.

ToMany 관계 (@OneToMany)

조인하면 데이터가 중복돼서 row 수가 늘어납니다.

예: Order ↔ OrderItem

주문 2개에 아이템이 각각 3개씩 있으면, 조인 시 결과 row는 6개가 됩니다.

→ 페이징이 깨지고, 데이터 뻥튀기 문제 생깁니다.

그래서 JPA에서는 ToOne은 join, ToMany는 별도 쿼리로 가져옵니다.